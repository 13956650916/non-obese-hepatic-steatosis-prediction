rm(list = ls())
data <- read.csv("after_wash_28.csv")[-1]
data <- data[,c("age","sbp","ALT","tyg","BMI","WC","TG","AST","Scr","UA","LDL","ALB","cmets","ALP","cap_lev")]
str(data)
table(data$cap_lev)
library(caret)
library(dplyr)
library(randomForest)
###数据预处理
# 连续变量标准化数据
data$cap_lev <- factor(
  data$cap_lev,
  levels = c(0, 1, 2),  # 替换为你的实际类别值
  labels = c("Class0", "Class1", "Class2"))
cont_vars <- sapply(data, is.numeric) & names(data) != "cap_lev" 
data[, cont_vars] <- scale(data[, cont_vars])
str(data)
#划分训练集验证集
set.seed(123)
splitIndex <- createDataPartition(data$cap_lev, p = .7, list = FALSE, times = 1)
train_data <- data[ splitIndex,]
val_data  <- data[-splitIndex,]
str(train_data)
str(val_data)
table(train_data$cap_lev)

table(val_data$cap_lev)
# 设置随机种子
set.seed(123)

# 计算类别权重
class_counts <- table(train_data$cap_lev)
class_weights <- sum(class_counts)/(length(class_counts)*class_counts)
class_weights_vector <- as.numeric(class_weights[levels(train_data$cap_lev)])

# 训练模型
ctrl <- trainControl(
  method = "cv",
  number = 5,
  classProbs = TRUE,
  summaryFunction = multiClassSummary
)

RF_model <- train(
  cap_lev ~ .,
  data = train_data,
  method = "ranger",
  trControl = ctrl,
  tuneGrid = data.frame(
    mtry = floor(sqrt(ncol(train_data)-1)), # 默认mtry值
    splitrule = "gini",
    min.node.size = 3
  ),
  metric = "Accuracy",
  num.trees = 200,
  max.depth = 13,
  class.weights = class_weights_vector,
  importance = "impurity",
  seed = 123
)

#训练集auc，看是否过拟合
pred_probs_t <- predict(RF_model, newdata = train_data, type = "prob")
pred_classes_t <- predict(RF_model, newdata = train_data, type = "raw")
pred_probs_v <- predict(RF_model, newdata = val_data, type = "prob")
pred_classes_v <- predict(RF_model, newdata = val_data, type = "raw")

#保存
saveRDS(RF_model, file = "RF_model.rds")
###训练集
RF_model <- readRDS("RF_model.rds")


###可视化---------------------------------------------------------------------------------
#训练集
#提取特征标签
x_train <- train_data[, -which(names(train_data) == "cap_lev")] # 特征, 替换"target"为您的目标变量列名
y_train <- train_data$cap_lev # 标签

### 混淆矩阵热力图
conf_matrix <- confusionMatrix(pred_classes_t, train_data$cap_lev)
conf_matrix_df <- as.data.frame(conf_matrix$table)

ggplot(conf_matrix_df, aes(x = Reference, y = Prediction, fill = Freq)) +
  geom_tile(color = "grey") +
  geom_text(aes(label = Freq), color = "black", size = 4) +
  scale_fill_gradient(low = "white", high = "steelblue",breaks = c(1000,2500,4000,5500,7000)) +
  theme_minimal() +
  theme(axis.text.y = element_text(angle = 90, vjust = 0.5, hjust=1)) + # 修改这一行来旋转y轴标签
  labs(title = "Train Confusion Matrix Using RF",
       x = "Actual Class",
       y = "Predicted Class")+ theme(plot.title = element_text(hjust = 0.5))


### 绘制ROC曲线
predicted_probs <- predict(RF_model, newdata = train_data, type = "prob")
# 计算各分类的ROC曲线
classes <- levels(train_data$cap_lev)
roc_data <- data.frame()
auc_values <- list()

for (cls in classes) {
  actual <- as.numeric(train_data$cap_lev == cls)
  prob <- predicted_probs[, cls]
  roc_obj <- roc(actual ~ prob, quiet = TRUE)  # 添加quiet=TRUE避免冗余提示
  # 显式使用pROC包的auc函数
  auc_values[[cls]] <- pROC::auc(roc_obj)  
  temp_df <- data.frame(
    FPR = 1 - roc_obj$specificities,
    TPR = roc_obj$sensitivities,
    Class = cls
  )
  roc_data <- rbind(roc_data, temp_df)
}
# 计算宏平均 AUC
macro_auc <- mean(unlist(auc_values))
print(macro_auc)
# 对于绘制宏平均ROC曲线，一种简单方法是将所有类别在相同FPR处的TPR值取平均
# 首先确定一个共同的FPR序列
fpr_seq <- seq(0, 1, by = 0.01)
# 初始化用于存储平均TPR的向量
mean_tpr <- rep(0, length(fpr_seq))
for (cls in classes) {
  roc_cls <- roc_data[roc_data$Class == cls, ]
  # 去除重复的FPR值，取对应TPR的平均值
  unique_fpr <- !duplicated(roc_cls$FPR)
  roc_cls <- roc_cls[unique_fpr, ]
  # 使用approx函数线性插值获取指定FPR下的TPR值
  tpr_interpolated <- approx(roc_cls$FPR, roc_cls$TPR, xout = fpr_seq, method = "linear", rule = 2)$y
  # 累加到mean_tpr
  mean_tpr <- mean_tpr + tpr_interpolated
}
# 计算平均TPR
mean_tpr <- mean_tpr / length(classes)
# 创建宏平均ROC数据框
macro_roc_data <- data.frame(
  FPR = fpr_seq,
  TPR = mean_tpr,
  Class = "Macro Avg"
)
# 计算微平均
# 生成真实标签的二进制矩阵（确保列顺序与classes一致）
actual_matrix <- model.matrix(~ cap_lev - 1, data = train_data)
colnames(actual_matrix) <- classes  # 确保列名与预测概率一致
# 将真实标签和预测概率展开为向量
actual_vector <- as.vector(actual_matrix)
prob_vector <- as.vector(as.matrix(predicted_probs))
# 计算微平均ROC曲线和AUC
micro_roc <- pROC::roc(response = actual_vector, predictor = prob_vector, quiet = TRUE)
micro_auc <- pROC::auc(micro_roc)
# 提取微平均ROC曲线的FPR和TPR
micro_roc_data <- data.frame(
  FPR = 1 - micro_roc$specificities,
  TPR = micro_roc$sensitivities,
  Class = "Micro Avg"
)

#绘图
all_roc_data <- rbind(roc_data, macro_roc_data, micro_roc_data)
# 生成绘图颜色向量（按类别顺序+宏平均+微平均）
class_order <- c(classes, "Macro Avg", "Micro Avg")
color_palette <- c("#23669a", "#c7813f", "#268927", "#a41118", "#570057")
used_colors <- color_palette[1:length(class_order)]

# 创建线型映射（OVR虚线，平均实线）
all_roc_data$LineType <- ifelse(all_roc_data$Class %in% classes, "dashed", "solid")

# 生成AUC标签数据
auc_values_all <- c(unlist(auc_values), macro_auc, micro_auc)
labels <- paste0(class_order, " (AUC=", round(auc_values_all, 3), ")")

# 标签定位参数
n_labels <- length(class_order)
y_start <- 0.25  # 起始高度
y_step <- 0.05   # 行间距

auc_labels <- data.frame(
  Class = factor(class_order, levels = class_order),
  label = labels,
  x = rep(0.70, n_labels),
  y = seq(y_start, by = -y_step, length.out = n_labels)
)

# 添加短线段数据
segments_data <- auc_labels %>%
  mutate(
    x_start = x - 0.05, # 调整短线起始位置使其靠近文本
    x_end = x - 0.01,
    y_start = y,
    y_end = y
  )

# 绘制ROC曲线并按要求改进
ggplot(all_roc_data, aes(x = FPR, y = TPR, color = Class)) +
  geom_line(aes(linetype = LineType), linewidth = 0.8) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "gray60") +
  scale_color_manual(values = used_colors) +
  scale_linetype_manual(values = c("dashed" = "dashed", "solid" = "solid")) +
  geom_segment(data = segments_data,
               aes(x = x_start, xend = x_end, y = y_start, yend = y_end, 
                   color = Class, linetype = ifelse(Class %in% classes, "dashed", "solid")),
               size = 0.8) + # 短线宽度
  geom_text(
    data = auc_labels,
    aes(x = x, y = y, label = label),
    hjust = 0, # 左对齐
    vjust = 0.5, # 垂直居中对齐
    size = 3.5,
    color = "black", # 字体颜色设为黑色
    show.legend = FALSE
  ) +
  coord_equal(ratio = 1, xlim = c(0, 1), ylim = c(0, 1)) +
  labs(title = "Train ROC Curves Using RF ", # 添加标题
       x = "False Positive Rate",
       y = "True Positive Rate") +
  theme_minimal() +
  theme(
    panel.grid.minor = element_blank(),
    panel.border = element_rect(fill = NA, color = "gray80"),
    legend.position = "none",
    aspect.ratio = 1,
    plot.title = element_text(hjust = 0.5) # 标题居中
  )



####验证集--------------------------------------------------
x_val <- val_data[, -which(names(val_data) == "cap_lev")] # 特征, 替换"target"为您的目标变量列名
y_val <- val_data$cap_lev # 标签
# 生成预测结果（假设test_data是测试数据集）
predicted_classes <- predict(RF_model, newdata = val_data, type = "raw")
predicted_probs <- predict(RF_model, newdata = val_data, type = "prob")

# 1. 混淆矩阵热力图
conf_matrix <- confusionMatrix(predicted_classes, val_data$cap_lev)
conf_matrix_df <- as.data.frame(conf_matrix$table)

ggplot(conf_matrix_df, aes(x = Reference, y = Prediction, fill = Freq)) +
  geom_tile(color = "grey") +
  geom_text(aes(label = Freq), color = "black", size = 4) +
  scale_fill_gradient(low = "white", high = "steelblue",breaks = c(500,1150,1800,2450)) +
  theme_minimal() +
  theme(axis.text.y = element_text(angle = 90, vjust = 0.5, hjust=1)) + # 修改这一行来旋转y轴标签
  labs(title = "Test Confusion Matrix Using RF",
       x = "Actual Class",
       y = "Predicted Class")+ theme(plot.title = element_text(hjust = 0.5))


### 绘制ROC曲线
predicted_probs <- predict(RF_model, newdata = val_data, type = "prob")
# 计算各分类的ROC曲线
classes <- levels(val_data$cap_lev)
roc_data <- data.frame()
auc_values <- list()

for (cls in classes) {
  actual <- as.numeric(val_data$cap_lev == cls)
  prob <- predicted_probs[, cls]
  roc_obj <- roc(actual ~ prob, quiet = TRUE)  # 添加quiet=TRUE避免冗余提示
  # 显式使用pROC包的auc函数
  auc_values[[cls]] <- pROC::auc(roc_obj)  
  temp_df <- data.frame(
    FPR = 1 - roc_obj$specificities,
    TPR = roc_obj$sensitivities,
    Class = cls
  )
  roc_data <- rbind(roc_data, temp_df)
}
# 计算宏平均 AUC
macro_auc <- mean(unlist(auc_values))
print(macro_auc)
# 对于绘制宏平均ROC曲线，一种简单方法是将所有类别在相同FPR处的TPR值取平均
# 首先确定一个共同的FPR序列
fpr_seq <- seq(0, 1, by = 0.01)
# 初始化用于存储平均TPR的向量
mean_tpr <- rep(0, length(fpr_seq))
for (cls in classes) {
  roc_cls <- roc_data[roc_data$Class == cls, ]
  # 去除重复的FPR值，取对应TPR的平均值
  unique_fpr <- !duplicated(roc_cls$FPR)
  roc_cls <- roc_cls[unique_fpr, ]
  # 使用approx函数线性插值获取指定FPR下的TPR值
  tpr_interpolated <- approx(roc_cls$FPR, roc_cls$TPR, xout = fpr_seq, method = "linear", rule = 2)$y
  # 累加到mean_tpr
  mean_tpr <- mean_tpr + tpr_interpolated
}
# 计算平均TPR
mean_tpr <- mean_tpr / length(classes)
# 创建宏平均ROC数据框
macro_roc_data <- data.frame(
  FPR = fpr_seq,
  TPR = mean_tpr,
  Class = "Macro Avg"
)
# 计算微平均
# 生成真实标签的二进制矩阵（确保列顺序与classes一致）
actual_matrix <- model.matrix(~ cap_lev - 1, data = val_data)
colnames(actual_matrix) <- classes  # 确保列名与预测概率一致
# 将真实标签和预测概率展开为向量
actual_vector <- as.vector(actual_matrix)
prob_vector <- as.vector(as.matrix(predicted_probs))
# 计算微平均ROC曲线和AUC
micro_roc <- pROC::roc(response = actual_vector, predictor = prob_vector, quiet = TRUE)
micro_auc <- pROC::auc(micro_roc)
# 提取微平均ROC曲线的FPR和TPR
micro_roc_data <- data.frame(
  FPR = 1 - micro_roc$specificities,
  TPR = micro_roc$sensitivities,
  Class = "Micro Avg"
)

#绘图
all_roc_data <- rbind(roc_data, macro_roc_data, micro_roc_data)
# 生成绘图颜色向量（按类别顺序+宏平均+微平均）
class_order <- c(classes, "Macro Avg", "Micro Avg")
color_palette <- c("#23669a", "#c7813f", "#268927", "#a41118", "#570057")
used_colors <- color_palette[1:length(class_order)]

# 创建线型映射（OVR虚线，平均实线）
all_roc_data$LineType <- ifelse(all_roc_data$Class %in% classes, "dashed", "solid")

# 生成AUC标签数据
auc_values_all <- c(unlist(auc_values), macro_auc, micro_auc)
labels <- paste0(class_order, " (AUC=", round(auc_values_all, 3), ")")

# 标签定位参数
n_labels <- length(class_order)
y_start <- 0.25  # 起始高度
y_step <- 0.05   # 行间距

auc_labels <- data.frame(
  Class = factor(class_order, levels = class_order),
  label = labels,
  x = rep(0.70, n_labels),
  y = seq(y_start, by = -y_step, length.out = n_labels)
)

# 添加短线段数据
segments_data <- auc_labels %>%
  mutate(
    x_start = x - 0.05, # 调整短线起始位置使其靠近文本
    x_end = x - 0.01,
    y_start = y,
    y_end = y
  )

# 绘制ROC曲线并按要求改进
ggplot(all_roc_data, aes(x = FPR, y = TPR, color = Class)) +
  geom_line(aes(linetype = LineType), linewidth = 0.8) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "gray60") +
  scale_color_manual(values = used_colors) +
  scale_linetype_manual(values = c("dashed" = "dashed", "solid" = "solid")) +
  geom_segment(data = segments_data,
               aes(x = x_start, xend = x_end, y = y_start, yend = y_end, 
                   color = Class, linetype = ifelse(Class %in% classes, "dashed", "solid")),
               size = 0.8) + # 短线宽度
  geom_text(
    data = auc_labels,
    aes(x = x, y = y, label = label),
    hjust = 0, # 左对齐
    vjust = 0.5, # 垂直居中对齐
    size = 3.5,
    color = "black", # 字体颜色设为黑色
    show.legend = FALSE
  ) +
  coord_equal(ratio = 1, xlim = c(0, 1), ylim = c(0, 1)) +
  labs(title = "Test ROC Curves Using RF", # 添加标题
       x = "False Positive Rate",
       y = "True Positive Rate") +
  theme_minimal() +
  theme(
    panel.grid.minor = element_blank(),
    panel.border = element_rect(fill = NA, color = "gray80"),
    legend.position = "none",
    aspect.ratio = 1,
    plot.title = element_text(hjust = 0.5) # 标题居中
  )


###PR曲线--------------------------------
library(PRROC)  # 用于计算PR曲线和PR AUC
library(rlang)
# 计算各分类的PR曲线和PR AUC
pr0 <- pr.curve(
  scores.class0 = pred_prob[true_labels == 0, 1],
  scores.class1 = pred_prob[true_labels != 0, 1],
  curve = TRUE
)

pr1 <- pr.curve(
  scores.class0 = pred_prob[true_labels == 1, 2],
  scores.class1 = pred_prob[true_labels != 1, 2],
  curve = TRUE
)

pr2 <- pr.curve(
  scores.class0 = pred_prob[true_labels == 2, 3],
  scores.class1 = pred_prob[true_labels != 2, 3],
  curve = TRUE
)

# 计算宏平均PR曲线
# 统一插值到相同长度的召回率点
common_recall <- seq(0, 1, length.out = 100)

interp_precision <- function(pr_obj) {
  # 预处理数据：去重并取平均精度
  recall <- pr_obj$curve[, 1]
  precision <- pr_obj$curve[, 2]
  df <- aggregate(precision ~ recall, data = data.frame(recall, precision), FUN = mean)
  df <- df[order(df$recall), ]  # 确保按recall升序排列
  # 线性插值到公共recall点
  approx(df$recall, df$precision, xout = common_recall, method = "linear", rule = 2)$y
}

macro_precision <- rowMeans(sapply(list(pr0, pr1, pr2), interp_precision), na.rm = TRUE)

# 计算微平均PR AUC
# 将所有类别的预测概率和真实标签合并
micro_true <- c()
micro_pred <- c()

for (i in seq_along(true_labels)) {
  k <- true_labels[i]
  # 对于当前样本，将其所属类别的预测概率作为正类
  micro_true <- c(micro_true, 1, 0, 0)
  micro_pred <- c(micro_pred, 
                  pred_prob[i, k + 1], 
                  pred_prob[i, setdiff(1:3, k + 1)][1],  # 取一个非正类的概率
                  pred_prob[i, setdiff(1:3, k + 1)][2]) # 取另一个非正类的概率
}

# 计算微平均PR曲线
pr_micro <- pr.curve(
  scores.class0 = micro_pred[micro_true == 1],
  scores.class1 = micro_pred[micro_true == 0],
  curve = TRUE
)

# 获取PR AUC值
prauc0 <- pr0$auc.integral
prauc1 <- pr1$auc.integral
prauc2 <- pr2$auc.integral
macro_prauc <- mean(c(prauc0, prauc1, prauc2))
micro_prauc <- pr_micro$auc.integral

# 准备标注数据
prauc_data <- data.frame(
  Type = c("none", "mild", "moderate_to_severe", "Macro Average", "Micro Average"),
  PR_AUC = c(prauc0, prauc1, prauc2, macro_prauc, micro_prauc),
  x = 0.70,  # x坐标位置
  y = seq(0.25, by = -0.05, length.out = 5),  # y坐标位置
  LineType = c("dashed", "dashed", "dashed", "solid", "solid")  # 线型
)

# 控制短线长度
short_line_length <- 0.04
prauc_data$x_shortline_end <- prauc_data$x - short_line_length

# 准备绘图数据
plot_data <- rbind(
  data.frame(
    Recall = pr0$curve[, 1], 
    Precision = pr0$curve[, 2], 
    Type = "none", 
    LineType = "dashed"
  ),
  data.frame(
    Recall = pr1$curve[, 1], 
    Precision = pr1$curve[, 2],
    Type = "mild", 
    LineType = "dashed"
  ),
  data.frame(
    Recall = pr2$curve[, 1], 
    Precision = pr2$curve[, 2],
    Type = "moderate_to_severe", 
    LineType = "dashed"
  ),
  data.frame(
    Recall = common_recall, 
    Precision = macro_precision,
    Type = "Macro Average", 
    LineType = "solid"
  ),
  data.frame(
    Recall = pr_micro$curve[, 1], 
    Precision = pr_micro$curve[, 2],
    Type = "Micro Average", 
    LineType = "solid"
  )
)

# 移除NaN值
plot_data <- plot_data[!is.na(plot_data$Precision), ]

# 绘制PR曲线图
ggplot(plot_data, aes(x = Recall, y = Precision)) +
  geom_line(aes(color = Type, linetype = LineType), linewidth = 0.8) +  
  geom_segment(
    data = prauc_data,
    aes(x = x_shortline_end, xend = x, y = y, yend = y,
        color = Type, linetype = LineType),
    size = 0.8
  ) + 
  geom_text(
    data = prauc_data,
    aes(x = x, y = y, 
        label = sprintf("%s (PR AUC=%.3f)", Type, PR_AUC),
        color = Type),
    hjust = 0, size = 3.5, show.legend = FALSE, color = "black"
  ) +
  scale_linetype_manual(values = c("dashed" = "dashed", "solid" = "solid")) +  
  scale_color_manual(
    values = c(
      "none" = "#E69F00",
      "mild" = "#009E73",
      "moderate_to_severe" = "#F0E442",
      "Macro Average" = "#0072B2",
      "Micro Average" = "#CC79A7"
    )
  ) +
  labs(
    x = "Recall", 
    y = "Precision",
    title = "PR Curves for XGBoost Model",
    subtitle = "Precision-Recall Trade-off Analysis"
  ) +
  theme_minimal() +
  theme(
    panel.grid.minor = element_blank(),
    panel.border = element_rect(fill = NA, color = "gray80"),
    legend.position = "none",
    aspect.ratio = 1,
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5, size = 11, color = "gray50"),
    axis.text = element_text(color = "black", size = 10),
    axis.title = element_text(size = 12, face = "bold")
  ) +
  coord_cartesian(
    xlim = c(0, 1), 
    ylim = c(0, 1),
    clip = "off"
  ) +
  scale_x_continuous(breaks = seq(0, 1, 0.2)) +
  scale_y_continuous(breaks = seq(0, 1, 0.2))
#------------------------------------个样本数值计算
# 计算每个类别的评估指标
calculate_class_metrics <- function(true_labels, pred_class, classes) {
  # 确保为因子，级别相同
  true_labels <- factor(true_labels, levels = classes)
  pred_class <- factor(pred_class, levels = classes)
  
  metrics_list <- list()
  
  for(cls in classes) {
    # 计算TP, FP, FN, TN
    tp <- sum(true_labels == cls & pred_class == cls)
    fp <- sum(true_labels != cls & pred_class == cls)
    fn <- sum(true_labels == cls & pred_class != cls)
    tn <- sum(true_labels != cls & pred_class != cls)
    
    # 计算指标
    precision <- ifelse((tp + fp) > 0, tp / (tp + fp), 0)
    recall <- ifelse((tp + fn) > 0, tp / (tp + fn), 0)  # Sensitivity/Recall相同
    f1 <- ifelse((precision + recall) > 0, 
                 2 * (precision * recall) / (precision + recall), 0)
    
    metrics_list[[as.character(cls)]] <- list(
      Class = cls,
      Precision = round(precision, 4),
      Sensitivity = round(recall, 4),  # Sensitivity就是Recall
      Recall = round(recall, 4),
      F1_Score = round(f1, 4),
      TP = tp,
      FP = fp,
      FN = fn,
      TN = tn
    )
  }
  
  return(metrics_list)
}

# 计算宏平均
calculate_macro_average <- function(metrics_list) {
  n_classes <- length(metrics_list)
  
  macro_precision <- mean(sapply(metrics_list, function(x) x$Precision))
  macro_recall <- mean(sapply(metrics_list, function(x) x$Recall))
  macro_f1 <- mean(sapply(metrics_list, function(x) x$F1_Score))
  
  return(list(
    Precision = round(macro_precision, 4),
    Sensitivity = round(macro_recall, 4),
    Recall = round(macro_recall, 4),
    F1_Score = round(macro_f1, 4)
  ))
}

# 计算微平均
calculate_micro_average <- function(true_labels, pred_class, classes) {
  true_labels <- factor(true_labels, levels = classes)
  pred_class <- factor(pred_class, levels = classes)
  
  # 汇总所有类别的TP, FP, FN
  total_tp <- 0
  total_fp <- 0
  total_fn <- 0
  
  for(cls in classes) {
    tp <- sum(true_labels == cls & pred_class == cls)
    fp <- sum(true_labels != cls & pred_class == cls)
    fn <- sum(true_labels == cls & pred_class != cls)
    
    total_tp <- total_tp + tp
    total_fp <- total_fp + fp
    total_fn <- total_fn + fn
  }
  
  # 计算微平均指标
  micro_precision <- ifelse((total_tp + total_fp) > 0, 
                            total_tp / (total_tp + total_fp), 0)
  micro_recall <- ifelse((total_tp + total_fn) > 0, 
                         total_tp / (total_tp + total_fn), 0)
  micro_f1 <- ifelse((micro_precision + micro_recall) > 0,
                     2 * (micro_precision * micro_recall) / 
                       (micro_precision + micro_recall), 0)
  
  return(list(
    Precision = round(micro_precision, 4),
    Sensitivity = round(micro_recall, 4),
    Recall = round(micro_recall, 4),
    F1_Score = round(micro_f1, 4),
    Total_TP = total_tp,
    Total_FP = total_fp,
    Total_FN = total_fn
  ))
}

# 准备数据
classes <- c("0", "1", "2")  # 根据您的类别名称调整

# 计算训练集指标
train_pred_class <- max.col(train_prob) - 1
train_metrics <- calculate_class_metrics(train_data$cap_lev, train_pred_class, classes)
train_macro <- calculate_macro_average(train_metrics)
train_micro <- calculate_micro_average(train_data$cap_lev, train_pred_class, classes)

# 计算验证集指标
val_pred_class <- max.col(val_prob) - 1
val_metrics <- calculate_class_metrics(val_data$cap_lev, val_pred_class, classes)
val_macro <- calculate_macro_average(val_metrics)
val_micro <- calculate_micro_average(val_data$cap_lev, val_pred_class, classes)


for(cls in classes) {
  m <- train_metrics[[cls]]
  cat(sprintf("  %-5s %-10.4f %-12.4f %-8.4f %-9.4f %-6d %-5d %-5d\n", 
              m$Class, m$Precision, m$Sensitivity, m$Recall, m$F1_Score,
              m$TP, m$FP, m$FN))
}
cat("\n汇总指标：\n")
cat(sprintf("宏平均：Precision=%.4f, Sensitivity=%.4f, Recall=%.4f, F1-Score=%.4f\n",
            train_macro$Precision, train_macro$Sensitivity, 
            train_macro$Recall, train_macro$F1_Score))
cat(sprintf("微平均：Precision=%.4f, Sensitivity=%.4f, Recall=%.4f, F1-Score=%.4f\n",
            train_micro$Precision, train_micro$Sensitivity,
            train_micro$Recall, train_micro$F1_Score))

# 修正分隔线部分的代码
cat("\n")
cat(rep("═", 60), sep = "", "\n")
cat("                     模型评估指标报告\n")
cat(rep("═", 60), sep = "", "\n\n")

cat("训练集评估结果：\n")
cat(rep("─", 50), sep = "", "\n")
cat("各分类指标：\n")
cat("Class  Precision  Sensitivity  Recall  F1-Score    TP    FP    FN\n")
cat(rep("─", 50), sep = "", "\n")
for(cls in classes) {
  m <- train_metrics[[cls]]
  cat(sprintf("  %-5s %-10.4f %-12.4f %-8.4f %-9.4f %-6d %-5d %-5d\n", 
              m$Class, m$Precision, m$Sensitivity, m$Recall, m$F1_Score,
              m$TP, m$FP, m$FN))
}
cat("\n汇总指标：\n")
cat(sprintf("宏平均：Precision=%.4f, Sensitivity=%.4f, Recall=%.4f, F1-Score=%.4f\n",
            train_macro$Precision, train_macro$Sensitivity, 
            train_macro$Recall, train_macro$F1_Score))
cat(sprintf("微平均：Precision=%.4f, Sensitivity=%.4f, Recall=%.4f, F1-Score=%.4f\n",
            train_micro$Precision, train_micro$Sensitivity,
            train_micro$Recall, train_micro$F1_Score))

cat("\n")
cat(rep("═", 60), sep = "", "\n")
cat("验证集评估结果：\n")
cat(rep("─", 50), sep = "", "\n")
cat("各分类指标：\n")
cat("Class  Precision  Sensitivity  Recall  F1-Score    TP    FP    FN\n")
cat(rep("─", 50), sep = "", "\n")
for(cls in classes) {
  m <- val_metrics[[cls]]
  cat(sprintf("  %-5s %-10.4f %-12.4f %-8.4f %-9.4f %-6d %-5d %-5d\n", 
              m$Class, m$Precision, m$Sensitivity, m$Recall, m$F1_Score,
              m$TP, m$FP, m$FN))
}
cat("\n汇总指标：\n")
cat(sprintf("宏平均：Precision=%.4f, Sensitivity=%.4f, Recall=%.4f, F1-Score=%.4f\n",
            val_macro$Precision, val_macro$Sensitivity, 
            val_macro$Recall, val_macro$F1_Score))
cat(sprintf("微平均：Precision=%.4f, Sensitivity=%.4f, Recall=%.4f, F1-Score=%.4f\n",
            val_micro$Precision, val_micro$Sensitivity,
            val_micro$Recall, val_micro$F1_Score))
cat("\n")
cat(sprintf("总样本数：%d\n", length(val_data$cap_lev)))
cat(sprintf("总TP数：%d, 总FP数：%d, 总FN数：%d\n", 
            train_micro$Total_TP, train_micro$Total_FP, train_micro$Total_FN))
cat(rep("═", 60), sep = "", "\n")

# 表格部分修正
cat("\n验证集分类性能汇总表：\n")
cat(paste0("+", paste0(rep("-", 55), collapse = ""), "+\n"))
cat("| 类别 | 精确率 | 灵敏度 | 召回率 | F1分数 | 支持数 |\n")
cat(paste0("+", paste0(rep("-", 55), collapse = ""), "+\n"))

# 计算每个类别的支持数（样本数）
for(cls in classes) {
  m <- val_metrics[[cls]]
  support <- m$TP + m$FN
  cat(sprintf("|  %-3s |  %-5.3f |  %-5.3f |  %-5.3f |  %-5.3f |  %-6d |\n",
              m$Class, m$Precision, m$Sensitivity, m$Recall, 
              m$F1_Score, support))
}

# 添加宏平均行
total_support <- length(val_data$cap_lev)
cat(paste0("+", paste0(rep("-", 55), collapse = ""), "+\n"))
cat(sprintf("| 宏平均 |  %-5.3f |  %-5.3f |  %-5.3f |  %-5.3f |  %-6d |\n",
            val_macro$Precision, val_macro$Sensitivity, 
            val_macro$Recall, val_macro$F1_Score, total_support))

# 添加微平均行
cat(sprintf("| 微平均 |  %-5.3f |  %-5.3f |  %-5.3f |  %-5.3f |  %-6d |\n",
            val_micro$Precision, val_micro$Sensitivity,
            val_micro$Recall, val_micro$F1_Score, total_support))
cat(paste0("+", paste0(rep("-", 55), collapse = ""), "+\n"))

# 计算每个类别的Specificity
calculate_specificity <- function(true_labels, pred_class, classes) {
  # 确保为因子，级别相同
  true_labels <- factor(true_labels, levels = classes)
  pred_class <- factor(pred_class, levels = classes)
  
  specificity_list <- list()
  
  for(cls in classes) {
    # 对于当前类别，将其视为正类，其他类别为负类
    # TN: 预测为负类且实际为负类
    # FP: 预测为正类但实际为负类
    
    # 计算TN: 预测为负类且实际为负类的数量
    tn <- sum(pred_class != cls & true_labels != cls)
    
    # 计算FP: 预测为正类但实际为负类的数量
    fp <- sum(pred_class == cls & true_labels != cls)
    
    # 计算Specificity
    specificity <- ifelse((tn + fp) > 0, tn / (tn + fp), 0)
    
    specificity_list[[cls]] <- round(specificity, 4)
  }
  
  return(specificity_list)
}

# 计算验证集的Specificity
val_pred_class <- max.col(val_prob) - 1
val_specificity <- calculate_specificity(val_data$cap_lev, val_pred_class, classes)

# 简单打印结果
cat("\n各分类Specificity（特异度）：\n")
for(cls in classes) {
  cat(sprintf("Class %s: %.4f\n", cls, val_specificity[[cls]]))
}

# 也可以计算宏平均和微平均Specificity
macro_specificity <- mean(unlist(val_specificity))

# 计算微平均Specificity
micro_tn_total <- 0
micro_fp_total <- 0

for(cls in classes) {
  # 计算每个类别的TN和FP
  true_labels <- factor(val_data$cap_lev, levels = classes)
  pred_class <- factor(val_pred_class, levels = classes)
  
  tn <- sum(pred_class != cls & true_labels != cls)
  fp <- sum(pred_class == cls & true_labels != cls)
  
  micro_tn_total <- micro_tn_total + tn
  micro_fp_total <- micro_fp_total + fp
}

micro_specificity <- ifelse((micro_tn_total + micro_fp_total) > 0, 
                            micro_tn_total / (micro_tn_total + micro_fp_total), 0)

cat(sprintf("\n宏平均Specificity: %.4f\n", macro_specificity))
cat(sprintf("微平均Specificity: %.4f\n", round(micro_specificity, 4)))

# 添加到之前的指标表格中（可选）
cat("\n完整指标表（包含Specificity）：\n")
cat("Class  Precision  Sensitivity  Specificity  F1-Score\n")
cat(rep("-", 55), sep = "", "\n")

for(cls in classes) {
  m <- val_metrics[[cls]]
  cat(sprintf("  %-5s %-10.4f %-12.4f %-12.4f %-9.4f\n", 
              cls, m$Precision, m$Sensitivity, val_specificity[[cls]], m$F1_Score))
}

library(psych)

# 准备数据（确保两个向量长度相同且都为数值型或因子型）
# 这里假设val_data$cap_lev已经是0,1,2的数值型
# val_pred_class也是0,1,2的数值型

# 创建2列的矩阵
kappa_matrix <- cbind(as.numeric(val_data$cap_lev), as.numeric(val_pred_class))

# 计算Cohen's Kappa
kappa_result <- cohen.kappa(kappa_matrix)

# 直接返回结果（不cat）
list(
  unweighted_kappa = kappa_result$kappa,
  weighted_kappa = kappa_result$weighted.kappa,
  confidence_interval = if(!is.null(kappa_result$confid)) kappa_result$confid[1, c(1,3)] else NULL
)

#-------------------------------校准曲线
# 准备数据
pred_prob <- predict(xgb_model, dval, reshape = TRUE) %>% 
  as.data.frame()
colnames(pred_prob) <- c("0", "1", "2")

# 确保标签为因子
true_labels <- factor(val_data$cap_lev, levels = c("0", "1", "2"))

# 转换为长格式
calibration_data <- pred_prob %>%
  mutate(obs = true_labels) %>%
  pivot_longer(
    cols = -obs,
    names_to = "pred_class",
    values_to = "pred_prob"
  ) %>%
  mutate(
    actual = as.integer(obs == pred_class),
    pred_class = factor(pred_class, levels = c("0", "1", "2"))
  )

# 分箱处理
calibration_bins <- calibration_data %>%
  group_by(pred_class) %>%
  mutate(
    prob_bin = cut(pred_prob, 
                   breaks = seq(0, 1, 0.1),
                   include.lowest = TRUE)
  ) %>%
  group_by(pred_class, prob_bin) %>%
  summarise(
    mean_pred = mean(pred_prob),
    mean_obs = mean(actual),
    n = n(),
    .groups = 'drop'
  ) %>%
  filter(n >= 5)

# 使用经典颜色：黄、绿、橙
classic_colors <- c(
  "0" = "#0D47A1",  # 黄色
  "1" = "#FF9800",  # 绿色
  "2" = "#4CAF50"   # 橙色
)

# 准备标注数据（只显示类别名称，去掉可靠性分数）
annotation_data <- data.frame(
  pred_class = factor(c("0", "1", "2"), levels = c("0", "1", "2")),
  x = 0.70,
  y = seq(0.25, by = -0.05, length.out = 3),
  label = c("Class 0", "Class 1", "Class 2")
)

# 控制短线长度
short_line_length <- 0.04
annotation_data$x_shortline_end <- annotation_data$x - short_line_length

# 绘制校准曲线
ggplot(calibration_bins, aes(x = mean_pred, y = mean_obs)) +
  # 完美校准对角线
  geom_abline(intercept = 0, slope = 1, color = "gray60", 
              linetype = "dashed", size = 0.5) +
  
  # 绘制校准曲线
  geom_line(aes(color = pred_class), size = 0.8) +
  geom_point(aes(color = pred_class, size = n), alpha = 0.7) +
  
  # 绘制连接标签的短线
  geom_segment(
    data = annotation_data,
    aes(x = x_shortline_end, xend = x, y = y, yend = y, color = pred_class),
    size = 0.8
  ) +
  
  # 添加标签（只显示类别名称）
  geom_text(
    data = annotation_data,
    aes(x = x, y = y, label = label, color = pred_class),
    hjust = 0, size = 3.5, show.legend = FALSE
  ) +
  
  # 设置颜色和尺寸
  scale_color_manual(values = classic_colors) +
  scale_size_continuous(range = c(2, 6)) +
  
  # 坐标轴和标题
  labs(
    x = "Mean Predicted Probability",
    y = "Observed Proportion",
    title = "Calibration Curves for XGBoost Model",
    color = "Class",
    size = "Sample Size"
  ) +
  
  # 主题设置
  theme_minimal() +
  theme(
    panel.grid.minor = element_blank(),
    panel.border = element_rect(fill = NA, color = "gray80"),
    legend.position = "none",  # 移除图例
    aspect.ratio = 1,
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
    axis.text = element_text(color = "black", size = 10),
    axis.title = element_text(size = 12, face = "bold")
  ) +
  
  # 坐标轴范围
  coord_cartesian(
    xlim = c(0, 1), 
    ylim = c(0, 1),
    clip = "off"
  ) +
  scale_x_continuous(breaks = seq(0, 1, 0.2)) +
  scale_y_continuous(breaks = seq(0, 1, 0.2))
